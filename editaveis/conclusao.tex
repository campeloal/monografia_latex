\chapter[Conclusão]{Conclusão}\

	 Por meio dos experimentos realizados, foi possível perceber que a complexidade assintótica,  no que diz respeito ao processo relacionado ao \textit{vertex shader}, se comportou linearmente, independentemente do \textit{shader} utilizado. Assim, todos os \textit{shaders} avaliados possuem a mesma complexidade algorítmica, mas as equações de cada um possuem coeficientes diferentes, que podem determinar qual \textit{shader} tem melhor ou pior desempenho. Analisando a teoria do processo de renderização da \textit{OpenGL} para o \textit{vertex shader}, este resultado é consistente, pois o programa do \textit{vertex shader} é utilizado para cada vértice, dependendo então do número de vértices e da complexidade do \textit{shader}.  Assim, o fluxo de execução da aplicação do \textit{vertex shader} pode ser representado de acordo com o Código \ref{vertex_proc}.

	 \lstinputlisting[language=C, caption = {Representação da aplicação do \textit{vertex shader}}, label = {vertex_proc}]{codigos/vertex_proc.txt}

	Já o processo de renderização como um todo e o relacionado ao \textit{fragment shader} tenderam a apresentar como complexidade assintótica um polinômio de segundo grau. O Código \ref{fragment_proc} mostra um fluxo genérico de execução da aplicação do \textit{fragment shader}. Assim, como é explicado na documentação da OpenGL\footnote{\textit{http://www.opengl.org/wiki/Fragment\_Shader}} e no Anexo \ref{renderpipe}, para cada primitiva da malha (no caso os triângulos), geram-se os fragmentos (possíveis candidatos a \textit{pixel}). E para cada fragmento, faz-se o processo de aplicação do \textit{fragment shader}, ressaltando que para cada fragmento percorre-se a direção horizontal e vertical da tela (sendo uma matriz). Assim, a função \texttt{executeFragmentShader(fragment)}, atribui a um fragmento uma cor e um valor de profundidade (este valor é usado nos passos sequentes do processo de renderização para descarte de fragmentos). Então possivelmente a complexidade assintótica quadrática está associada à atribuição da cor (que percorre uma matriz, sendo de ordem quadrada). 

	 \lstinputlisting[language=C, caption = {Representação da aplicação do \textit{fragment shader}}, label = {fragment_proc}]{codigos/fragment_proc.txt}

	Além disso, os resultados obtidos não são tão óbvios, pois ao analisar o programa do \textit{vertex shader} do Código \ref{vertex_program}, por exemplo, há somente uma atribuição, induzindo o programador  a achar que a complexidade é constante, em que o trabalho desenvolvido evidenciou a verdadeira complexidade do algoritmo.

	\lstinputlisting[language=C, caption = {Exemplo de programa do \textit{vertex shader}}, label = {vertex_program}]{codigos/red_vs.txt} 
	
	Assim, como todos os \textit{shaders} (do mesmo tipo) apresentam a mesma complexidade assintótica, uma forma de comparar o desempenho entre eles, para um mesmo dispositivo, é através do processo realizado neste trabalho (explicado na Seção \ref{result}), que resulta no cálculo das funções de cada \textit{shader}. Esta comparação pode ser feita por meio da análise destas funções obtidas, comparando-se os seus coeficientes. Esta análise pode ser realizada com relação a todo o processo de renderização (utilizando a medida de tempo de renderização feita pela GPU) ou especificadamente ao \textit{vertex shader} ou \textit{fragment shader} -- como neste trabalho, em que foram utilizados as medidas específicas de instruções por segundo por vértice/fragmento).  Isto pode ser feito para comparar diferentes \textit{shaders} ou para saber o quanto um \textit{shader} foi otimizado (comparando-se o anterior e o atual). 

	Além disso, também é possível comparar, para um mesmo \textit{shader}, diferentes dispositivos por meio das equações e valores das medições obtidos. As comparações realizadas neste trabalho foram condizentes com a expectativa, o dispositivo \textit{iPhone 5s},  que é de uma geração de \textit{smartphones} mais recente, por exemplo, teve desempenho muito melhor que o \textit{Nexus 4}.   	

	Outra contribuição importante foi quanto à automatização da maior parte deste processo de análise da complexidade algorítmica, como a estrutura para aplicação dos \textit{shaders}, média das medições, plotagem, ajuste das curvas e cálculo das funções. Assim, tal procedimento pode ser reproduzido de forma rápida e confiável. 
